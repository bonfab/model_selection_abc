#replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, rep(1, K)[1,]))))
}
pop <- replicate(number_locus, admixture(), simplify = T)
#print(pop)
return(pop)
}
generate_admixture_prior <- function(K, number_locus, pop_size = 50, alpha = 1, beta = 1){
set_alphas <- function(pop){
alphas <- rep(1, K)
alphas[pop] <- 1 + rbeta(1, 1.25, 1)
return(alphas)
}
#set.seed(1)
admixture <- function(){
prob_locus <- rbeta(K, alpha, beta)
sapply(1:K, function(p) replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, set_alphas(p))[1,]))))
#replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, rep(1, K)[1,]))))
}
pop <- replicate(number_locus, admixture(), simplify = T)
#print(pop)
return(pop)
}
generate_correlated <- function(K, number_locus, pop_size = 200, number_alleles = 8, alphas = NULL){
correlate_locus <- function(){
corr <- rgamma(1, 7.5)
return(replicate(K, rcat(n = pop_size, p = rdirichlet(1, rep(corr, times = number_alleles))[1,])))
}
pop <- replicate(number_locus, correlate_locus(), simplify = T)
return(pop)
}
generate_simple_dirichlet <- function(K, number_locus, pop_size = 25, number_alleles = 8, alphas = NULL){
if(is.null(alphas)){
alphas = rep(1, times = number_alleles)
}
pop <- replicate(number_locus, replicate(K, rcat(n = pop_size, p =rdirichlet(1, alphas)[1,])), simplify = T)
return(pop)
}
PCA_summary <- function(data, reduce_to = 25){
data <- data[, apply(data, 2, function(x) !(length(unique(x)) == 1))]
pca <- prcomp(data, scale = T)
#trunc <- pca$rotation[,1:reduce_to] %*% pca$x[1:reduce_to,1:reduce_to]
#plot(pca)
#print(pca$x[1:reduce_to, 1:reduce_to])
#print(pca$sdev[1:reduce_to])
#print(pca$sdev[1:reduce_to])
eigen_sum <- sum(pca$sdev)
#print(eigen_sum)
#print(pca$sdev[1:reduce_to])
return(pca$sdev[1:reduce_to]/eigen_sum)
}
sparse_pca <- function(microarry, K){
selected <- spca(microarry, K, rep(100, K))
print(selected)
}
make_data <- function(samples = 500, populations = 3:8){
clust <- makeCluster(detectCores()-2)
clusterExport(cl=clust, varlist=c("PCA_summary", "generate_admixture_prior", "rdirichlet"))
#pop <- do.call(rbind, lapply(populations, function(x) t(replicate(samples, PCA_summary(generate_admixture_prior(x, 10000))))))
#pop <- do.call(rbind, parLapply(clust, populations, function(x) t(replicate(samples, PCA_summary(generate_admixture_prior(x, 10000))))))
label <- unlist(lapply(populations, function(x) rep(x, samples)))
print("begin generation")
pop <- do.call(rbind, parLapply(clust, label, function(x) PCA_summary(generate_admixture_prior(x, 10000))))
#print(pop)
#print(label)
saveRDS(list(pop, label), "data_pop_prio_1-25.rds")
#saveRDS(list(pop, label), "data_pop.rds")
}
#source("reduce_kernels.R")
#stat <- generate_simple_dirichlet(5, 10000)
#summary <- PCA_summary(stat)
#red <- make_similarity_matrix(stat)
#PCA_summary(red)
#print(red)
#stat <- generate_correlated(6, 10000)
#print(stat)
stat <- generate_admixture_prior(5, 5000)
s <- PCA_summary(stat)
print(s)
#s2 <- sparse_pca(stat, 10)
#make_data()
#bla <- readRDS("data_pop.rds")
#print(do.call(rbind, bla[[1]]))
a <- c(1, 2, 3)
b <- c(1, 3, 4)
c <- rbind(a, b)
c[, apply(c, 2, function(x) !(length(unique(x)) == 1))]
source("gradient_boosting.R")
load_data <- function(RDS_file = "data_pop_prio_1-25_1.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
m <- load_data()
normalize <- min(m[,length(m[1,])])
model <- trainXGBoost(m[,1:length(m[1,]) -1], m[,length(m[1,])] - normalize)
source("gradient_boosting.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25_1.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
m <- load_data()
normalize <- min(m[,length(m[1,])])
model <- trainXGBoost(m[,1:length(m[1,]) -1], m[,length(m[1,])] - normalize)
source("gradient_boosting.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
m <- load_data()
normalize <- min(m[,length(m[1,])])
model <- trainXGBoost(m[,1:length(m[1,]) -1], m[,length(m[1,])] - normalize)
View(m)
nrow
?nrow
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(test_indices)
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(test_indices)
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
print(labels)
for(class in unique(labels)){
class_indices <- which(labels == class)
append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(test_indices)
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
#test_indices <- list()
print(labels)
for(class in unique(labels)){
class_indices <- which(labels == class)
print(class_indices)
append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(test_indices)
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
#print(labels)
for(class in unique(labels)){
class_indices <- which(labels == class)
print(class_indices)
append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(test_indices)
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
?append
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(test_indices)
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(as.vector(test_indices))
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(as.vector(test_indices))
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(as.vector(test_indices))
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
print(as.vector(indices))
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(unlist(test_indices, use.names = F))
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
#print(as.vector(indices))
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(unlist(test_indices, use.names = F))
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
#print(as.vector(indices))
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
validateOutput(predictions, test[,ncol(test)] - xgb_compatible)
library(parallel)
library(MCMCpack)
library(LaplacesDemon)
library(elasticnet)
generate_simple <- function(K, number_locus, pop_size = 100, alpha = .1, beta = 1){
#set.seed(1)
pop <- replicate(number_locus, replicate(K, rbinom(n = pop_size, size = 1, prob = rbeta(1, alpha, beta))), simplify = T)
#print(pop)
return(pop)
}
generate_admixture <- function(K, number_locus, pop_size = 100, alpha = 1, beta = 1, concentration = 1.5){
set_alphas <- function(pop){
alphas <- rep(1, K)
alphas[pop] <- concentration
return(alphas)
}
#set.seed(1)
admixture <- function(){
prob_locus <- rbeta(K, alpha, beta)
sapply(1:K, function(p) replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, set_alphas(p))[1,]))))
#replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, rep(1, K)[1,]))))
}
pop <- replicate(number_locus, admixture(), simplify = T)
#print(pop)
return(pop)
}
generate_admixture_prior <- function(K, number_locus, pop_size = 50, alpha = 1, beta = 1){
set_alphas <- function(pop){
alphas <- rep(1, K)
alphas[pop] <- 1 + rbeta(1, 1.25, 1)
return(alphas)
}
#set.seed(1)
admixture <- function(){
prob_locus <- rbeta(K, alpha, beta)
sapply(1:K, function(p) replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, set_alphas(p))[1,]))))
#replicate(pop_size, rbinom(1, 2, sum(prob_locus * rdirichlet(1, rep(1, K)[1,]))))
}
pop <- replicate(number_locus, admixture(), simplify = T)
#print(pop)
return(pop)
}
generate_correlated <- function(K, number_locus, pop_size = 200, number_alleles = 8, alphas = NULL){
correlate_locus <- function(){
corr <- rgamma(1, 7.5)
return(replicate(K, rcat(n = pop_size, p = rdirichlet(1, rep(corr, times = number_alleles))[1,])))
}
pop <- replicate(number_locus, correlate_locus(), simplify = T)
return(pop)
}
generate_simple_dirichlet <- function(K, number_locus, pop_size = 25, number_alleles = 8, alphas = NULL){
if(is.null(alphas)){
alphas = rep(1, times = number_alleles)
}
pop <- replicate(number_locus, replicate(K, rcat(n = pop_size, p =rdirichlet(1, alphas)[1,])), simplify = T)
return(pop)
}
PCA_summary <- function(data, reduce_to = 25){
data <- data[, apply(data, 2, function(x) !(length(unique(x)) == 1))]
pca <- prcomp(data, scale = T)
#trunc <- pca$rotation[,1:reduce_to] %*% pca$x[1:reduce_to,1:reduce_to]
#plot(pca)
#print(pca$x[1:reduce_to, 1:reduce_to])
#print(pca$sdev[1:reduce_to])
#print(pca$sdev[1:reduce_to])
eigen_sum <- sum(pca$sdev)
#print(eigen_sum)
#print(pca$sdev[1:reduce_to])
return(pca$sdev[1:reduce_to]/eigen_sum)
}
sparse_pca <- function(microarry, K){
selected <- spca(microarry, K, rep(100, K))
print(selected)
}
make_data <- function(samples = 500, populations = 3:8){
clust <- makeCluster(detectCores())
clusterExport(cl=clust, varlist=c("PCA_summary", "generate_admixture_prior", "rdirichlet"))
#pop <- do.call(rbind, lapply(populations, function(x) t(replicate(samples, PCA_summary(generate_admixture_prior(x, 10000))))))
#pop <- do.call(rbind, parLapply(clust, populations, function(x) t(replicate(samples, PCA_summary(generate_admixture_prior(x, 10000))))))
label <- unlist(lapply(populations, function(x) rep(x, samples)))
print("begin generation")
pop <- do.call(rbind, parLapply(clust, label, function(x) PCA_summary(generate_admixture_prior(x, 10000))))
#print(pop)
#print(label)
saveRDS(list(pop, label), "data_pop_prio_1-25.rds")
#saveRDS(list(pop, label), "data_pop.rds")
}
#source("reduce_kernels.R")
#stat <- generate_simple_dirichlet(5, 10000)
#summary <- PCA_summary(stat)
#red <- make_similarity_matrix(stat)
#PCA_summary(red)
#print(red)
#stat <- generate_correlated(6, 10000)
#print(stat)
#stat <- generate_admixture_prior(5, 5000)
#s <- PCA_summary(stat)
#print(s)
#s2 <- sparse_pca(stat, 10)
make_data()
source("gradient_boosting.R")
source("testing.R")
load_data <- function(RDS_file = "./data_pop_prio_1-25.rds"){
data <- readRDS(RDS_file)
return(cbind(data[[1]], data[[2]]))
}
get_test_indices <- function(labels, proportion = 0.1){
test_indices <- list()
for(class in unique(labels)){
class_indices <- which(labels == class)
test_indices <- append(test_indices, class_indices[1:floor(length(class_indices) * 0.1)])
}
return(unlist(test_indices, use.names = F))
}
m <- load_data()
indices <- get_test_indices(m[,ncol(m)])
print(indices)
#print(as.vector(indices))
train <- m[-indices,]
train <- train[sample(nrow(train)),]
test <- m[indices,]
test <- test[sample(nrow(test)),]  # not really necessary
xgb_compatible <- min(m[,length(m[1,])])
model <- trainXGBoost(train[,1:ncol(train) -1], train[,ncol(train)] - xgb_compatible)
predictions <- classifyXGBoost(model, test[,1:ncol(test)-1])
validateOutput(predictions, test[,ncol(test)] - xgb_compatible)
